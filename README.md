Notification System
Project Overview

This project implements a real-time notification system using .NET 10.
It handles notifications generated by different services (e.g., OrderService, PaymentService) and stores them in an in-memory queue.
A worker service (consumer) continuously processes these notifications and sends them through the appropriate channel (Email, SMS, Push) according to priority and retry rules.

The system provides:
- Priority-based delivery
- Retry mechanism with exponential backoff
- Thread-safe in-memory queue
- Multi-threaded consumer processing

Technologies Used
- .NET 10
- C#
- Multi-threading (Thread, Monitor, lock)
- In-memory Queue (SortedDictionary<Priority, Queue<Notification>>)
- Producer/Consumer Pattern
- Retry & exponential backoff
- Dependency Injection (API & Worker)
- Worker Service / Background Processing

Notification Model

Each notification has a type, priority, status, retry count, and timestamp.
- NotificationType → Email, SMS, or Push channel
- Priority → defines the order of delivery: Critical, High, Normal, Low
- Status → current state of the notification: Pending, Processing, Sent, Failed
- RetryCount → tracks the number of retries in case of delivery failure

Queue Logic (In-Memory Queue)
- Thread-safe in-memory queue stores all notifications.
- SortedDictionary<Priority, Queue<Notification>> ensures priority-based processing without extra sorting.
- Producer/Consumer pattern is implemented using Monitor.Wait and Monitor.Pulse:
  - Producers (API services) add notifications and call Monitor.Pulse to notify consumers.
  - Consumers (worker threads) wait if the queue is empty and automatically wake up when new notifications arrive.

Why this design?
- No external message broker is needed, everything runs in memory.
- Critical notifications are always processed first (using Reverse() when dequeuing).
- Multi-threading ensures several notifications can be processed concurrently.

Worker Service & Notification Processing
- NotificationProcessor continuously consumes notifications from the queue.
- Each type of notification has its corresponding channel (EmailChannel, SMSChannel, PushChannel).
- The worker can run multiple threads to process notifications in parallel (e.g., 3 threads).
- Notifications are sent according to priority, and retries are handled with exponential backoff:

Multi-threading & Synchronization
- lock ensures thread-safe queue operations.
- Monitor.Wait allows consumers to wait efficiently when the queue is empty.
- Monitor.Pulse wakes a waiting consumer when a new notification is added.
- Monitor.PulseAll is used during shutdown to wake all threads.

This structure allows the system to prioritize urgent notifications and handle retries automatically.

Retry Mechanism
- Maximum retries: 3
- Exponential backoff prevents overwhelming external services like SMTP servers or SMS APIs.
- Failed notifications are marked Failed after reaching max retries, allowing later inspection or logging.

Notes & Best Practices
- The system is in-memory, so notifications are not persistent after application restart.
- You can later integrate external brokers (RabbitMQ, Kafka, Azure Service Bus) for durability.
- Priority and retry logic ensures critical notifications are always sent first.
